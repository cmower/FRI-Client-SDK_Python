import argparse
import math
import sys

import numpy as np

import pyfri as fri


class LBRWrenchSineOverlayClient(fri.LBRClient):
    """
    Generates a sine wave pattern for joint positions and wrench values to be sent
    to a robot arm during monitoring or commanding periods. It adjusts the phase
    of the sine waves based on time steps and resets them at each cycle.

    Attributes:
        frequencyX (float): Initialized with a value received during object creation,
            which represents the frequency of the sine wave to be applied along
            the x-axis.
        frequencyY (float): Stored as a private instance variable of the class.
            It represents the frequency of the sinusoidal component along the
            Y-axis in the wrench command generated by this client.
        amplitudeX (float): Set to a user-provided value during initialization.
            It determines the amplitude of the sine wave applied to axis X of the
            wrench.
        amplitudeY (float): 1:1 associated with a sine wave's maximum displacement
            from its equilibrium position along the Y-axis.
        stepWidthX (float): 0.0 by default, initially not being used but later
            calculated based on the frequency of a sine wave applied to a robot's
            joint.
        stepWidthY (float): 0 by default. It stores the time interval between two
            sine wave samples along the y-axis, calculated as `2.0 * pi * frequencyY
            * sampleTime`.
        phiX (float): 0 by default. It represents a phase offset used to calculate
            a sine wave for the x-axis in wrench commands.
        phiY (float): Initialized to 0. It accumulates a value that increases at
            each call of the `command` method, representing the phase shift in
            radians for the sine wave applied along the Y-axis of the wrench command.
        wrench (npndarray|List[float]): 6 elements long. It represents a set of
            six force/torque values to be applied to a robot in three-dimensional
            space: forces along the x, y, z axes and torques around these axes.

    """
    def __init__(self, frequencyX, frequencyY, amplitudeX, amplitudeY):
        """
        Initializes its attributes, setting default values for certain variables
        and importing np to create a 6-element array representing a wrench. It
        also calls the parent class's `__init__` method using super().

        Args:
            frequencyX (float): Used to represent the frequency in the X direction
                of an oscillating signal or wave. It is initialized with a provided
                value within the function's call.
            frequencyY (float): Initialized with user-provided value `frequencyY`.
                It represents the frequency of oscillation in the y-direction of
                an object or system, likely used for modeling or simulation purposes.
            amplitudeX (float): Used to specify the amplitude (magnitude) of the
                x-component of a signal, such as a wave or oscillation. It represents
                the maximum displacement from equilibrium.
            amplitudeY (float): Used to initialize an instance variable representing
                the amplitude along the Y-axis of the object's movement or oscillation.

        """
        super().__init__()
        self.frequencyX = frequencyX
        self.frequencyY = frequencyY
        self.amplitudeX = amplitudeX
        self.amplitudeY = amplitudeY
        self.stepWidthX = 0.0
        self.stepWidthY = 0.0
        self.phiX = 0.0
        self.phiY = 0.0
        self.wrench = np.zeros(6, dtype=np.float32)

    def monitor(self):
        pass

    def onStateChange(self, old_state, new_state):
        """
        Resets certain attributes when the robot enters the MONITORING_READY state,
        likely indicating a change in operational mode or readiness for motion
        control. It also calculates step widths based on frequency and sample time.

        Args:
            old_state (fri.ESessionState): Referenced when determining whether a
                state change has occurred from a previous state to the new state,
                which is specified by `new_state`.
            new_state (EnumMember[fri.ESessionState]): Compared to
                fri.ESessionState.MONITORING_READY to check if the session state
                has changed into monitoring ready state.

        """
        if new_state == fri.ESessionState.MONITORING_READY:
            self.phiX = 0.0
            self.phiY = 0.0
            self.stepWidthX = (
                2.0 * math.pi * self.frequencyX * self.robotState().getSampleTime()
            )
            self.stepWidthY = (
                2.0 * math.pi * self.frequencyY * self.robotState().getSampleTime()
            )

    def waitForCommand(self):
        """
        Sends the current joint position to the robot and sets the wrench value
        if the client command mode is WRENCH. This ensures synchronization between
        the robot's state and the client's commands.

        """
        self.robotCommand().setJointPosition(self.robotState().getIpoJointPosition())
        if self.robotState().getClientCommandMode() == fri.EClientCommandMode.WRENCH:
            self.robotCommand().setWrench(self.wrench)

    def command(self):
        """
        Sets the joint position and wrench commands for a robotic arm. The wrench
        command is generated based on sine wave amplitudes that increase over time,
        simulating an oscillating force applied to the arm in both X and Y directions.

        """
        self.robotCommand().setJointPosition(self.robotState().getIpoJointPosition())
        if self.robotState().getClientCommandMode() == fri.EClientCommandMode.WRENCH:
            self.wrench[0] = self.amplitudeX * math.sin(self.phiX)
            self.wrench[1] = self.amplitudeY * math.sin(self.phiY)

            self.phiX += self.stepWidthX
            self.phiY += self.stepWidthY

            if self.phiX >= 2.0 * math.pi:
                self.phiX -= 2.0 * math.pi

            if self.phiY >= 2.0 * math.pi:
                self.phiY -= 2.0 * math.pi

            self.robotCommand().setWrench(self.wrench)


def args_factory():
    """
    Parses command-line arguments using the `argparse` module, allowing for
    configuration of application settings such as hostname, port, and
    frequencies/amplitudes of sine waves. The parsed arguments are returned as an
    object.

    Returns:
        argparseNamespace: An object containing all arguments parsed from command
        line input, such as hostname, port, frequencyX, frequencyY, amplitudeX,
        and amplitudeY.

    """
    parser = argparse.ArgumentParser(description="LRBJointSineOverlay example.")
    parser.add_argument(
        "--hostname",
        dest="hostname",
        default=None,
        help="The hostname used to communicate with the KUKA Sunrise Controller.",
    )
    parser.add_argument(
        "--port",
        dest="port",
        type=int,
        default=30200,
        help="The port number used to communicate with the KUKA Sunrise Controller.",
    )
    parser.add_argument(
        "--frequencyx",
        dest="frequencyX",
        type=float,
        default=0.25,
        help="The frequency of sine wave in x-axis.",
    )
    parser.add_argument(
        "--frequencyy",
        dest="frequencyY",
        type=float,
        default=0.25,
        help="The frequency of sine wave in y-axis.",
    )
    parser.add_argument(
        "--amplitudex",
        dest="amplitudeX",
        type=float,
        default=5.0,
        help="The amplitude of sine wave in x-axis.",
    )
    parser.add_argument(
        "--amplitudey",
        dest="amplitudeY",
        type=float,
        default=5.0,
        help="The amplitude of sine wave in y-axis.",
    )

    return parser.parse_args()


def main():
    """
    Initializes a client application for interacting with a KUKA Sunrise controller,
    connects to it, runs an infinite loop where it steps through the application
    and checks the robot's state until idle or interrupted by a keyboard signal,
    then disconnects from the controller.

    Returns:
        int|None: 0 when connection to KUKA Sunrise controller is successful and
        1 otherwise, depending on whether the function was able to connect to the
        controller successfully or not.

    """
    print("Running FRI Version:", fri.FRI_CLIENT_VERSION)

    args = args_factory()
    print(args)
    client = LBRWrenchSineOverlayClient(
        args.frequencyX, args.frequencyY, args.amplitudeX, args.amplitudeY
    )
    app = fri.ClientApplication(client)
    success = app.connect(args.port, args.hostname)

    if not success:
        print("Connection to KUKA Sunrise controller failed.")
        return 1

    try:
        while success:
            success = app.step()

            if client.robotState().getSessionState() == fri.ESessionState.IDLE:
                break

    except KeyboardInterrupt:
        pass

    finally:
        app.disconnect()

    return 0


if __name__ == "__main__":
    sys.exit(main())
